---
title: 数据库面试要点
date: 2019-03-04 14:49:39
categories: 数据库
tags: 面试
---
数据库基本概念，数据结构，常用引擎，索引注意点，事务并发问题和并发控制的实现，加锁机制等。
<!-- more -->
## 1.基本概念
### 三级模式
1. 外模式（数据库用户的数据视图）
2. 模式（全局数据视图）
3. 内模式（物理存储方式）

### 两级映像
1. 外模式/模式，保证逻辑独立性
2. 模式/内模式，保证物理独立性

### 三范式
1. 每一列都是原子的，不可再分的
2. 保证第一范式，不存在部分依赖
3. 保证第二范式，不存在传递依赖

### MySQL的数据库引擎
1. ISAM：读取快，不支持事务，外键
2. MyISAM：基于ISAM，支持表级锁
3. archive： 提供压缩功能，适合大数据量的历史数据，插入快，无索引，查询慢
4. blackhole：用作日志记录
5. heap：数据存在内存，每个表对应一个磁盘文件，表结构存在磁盘
6. csv：基于普通文本，每个数据占一个文本行
7. performance schame：用于收集数据库服务器的参数
8. InnoDB：提供ACID事务（原子性，一致性，隔离性，持久性），多版本并发控制，支持索引，5.5之后的默认引擎。

### 死锁的四个必要条件
1. 互斥
2. 不可剥夺
3. 请求与保持
4. 环路等待

### 显示加锁
```
// 显示加行级锁
select ... lock in share mode(加S锁)
select ... for update(加X锁)

// 显示加表级锁
SET AUTOCOMMIT=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
[do something with tables t1 and here];
COMMIT;
UNLOCK TABLES;
```

## 2.索引数据结构

### B树和B+树
#### B树
1. 多路搜索树,每个节点包含n个key，data和n+1个指针指向下一层的节点

#### B+树
1. 多路搜索树，每个节点包含n个key和n个指向下一层个节点的指针和一个指向兄弟节点的指针
2. 非叶子节点不存储数据，叶子节点存储数据并包含一个指向兄弟节点的指针。
3. 每个节点大小为一个物理存储页的大小，linux下一般为4k，减少了磁盘I/O

#### B+树快的原因
1. 多路搜索树，查询复杂度为logm(n)
2. 每个节点大小为一个物理存储页的大小，linux下一般为4k，减少了磁盘I/O
3. 每个非叶子节点只存储key而不存储实际数据，搜索变得稳定。
4. 每个节点有指向兄弟节点的指针，对于范围查找变得更快。

#### 聚簇索引和非聚簇索引

##### 聚簇索引
逻辑结构和物理结构一致，叶子节点存储的就是数据
##### 非聚簇索引
逻辑结构和物理结构不一致，叶子节点存储的不是直接的数据。如InnoDB的二级索引的叶子节点为主键值，MyISAM二级索引叶子节点指向的为数据物理存储地址的指针

## 3.索引分类和注意点
### 索引分类
索引分类：主键索引，普通索引，唯一索引，全文索引，组合索引

### 使用索引注意点
- 索引字段默认值不要设置null，索引不会包含null值
- MySQL查询时只会使用一种索引
- 有索引的列参与计算时，不会走此索引，尽量直接使用索引列而不要使索引列参与计算
- 组合索引为最左匹配，如建立（a, b, c）索引时会同时建立（a）, (a, b), (a, b, c)
- 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！因为InnoDB的行锁是通过索引上的索引项来实现的。
- 当查询的列为组合索引中的字段，则此二级索引不需要回表操作，直接返回数据。因为组合索引上保存了组合索引包含的字段信息。

## 4.事务
### 事务的隔离级别
1. 读未提交
2. 读已提交
3. 可重复读
4. 串行化

### 事务并发带来的问题
1. 丢失修改（事务B的修改覆盖了未完成事务A的修改）
2. 读脏数据（事务B读取了未完成事务A的未提交更新）
3. 不可重复读
- 事务A两次用相同的sql读取数据，其间事务B修改了数据
- 事务A两次用相同的sql读取数据，其间事务B添加或删除了符合sql的数据（幻读）
标准的InnoDB的可重复读并未解决幻读的问题，幻读是InnoDB的MVCC解决的。

### LBCC(Lock-Based Concurrent Controll，基于锁的并发控制，封锁协议)
#### 一级封锁协议
写数据前加X锁，事务结束后释放
#### 二级封锁协议
满足一级封锁协议，读数据前加S锁，读完释放
#### 三级封锁协议
满足一级封锁协议，读数据前加S锁，事务结束后释放

### MVCC(Multi-Version Concurrent Controller，多版本并发控制)
#### 快照读和当前读
- 快照读：仅读取记录的可见版本，可能是历史版本。不会对返回的数据集加锁
简单的查询都属于快照读

- 当前读：读取记录的最新版本。并对返回的数据集一行一行得加锁。
```
select * from table where ? lock in share mode; （加S锁）
select * from table where ? for update; （加X锁，下同）
insert, update, delete操作
```

#### 死锁
当两个（或以上）Session以不同的顺序对同一(或若干)数据行加锁，则可能出现死锁。
{% asset_img 死锁1.jpg %}
{% asset_img 死锁2.jpg %}

#### InnoDB的MVCC实现机制
##### 概括
InnoDB的MVCC，通过在每行数据后面保存两个隐藏的列，创建版本号和删除版本号来实现。每开始一个新的事务，系统版本号就会递增1。MVCC只在RC（读已提交）和RR（可重复读）两个隔离级别工作，另外两个隔离界别与MVCC不兼容。

##### MVCC实现Repeatable Read （可重复读）的隔离级别
1. select：create_id < current_id < delete_id
2. insert: create_id = current_id
3. delete: delete_id = current_id
4. update: insert + delete, 插入一条create_id = current_id的记录，将原记录delete_id = current_id

InnoDB后台运行线程，删除delete_id < current_id的记录，称为purge操作。

##### MVCC中RC和RR隔离级别的区别
在RR隔离级别下，事务中的普通读取都是快照读，即别的事务修改的数据在此事务中读不到
在RC隔离级别下，事务中的读取总是当前读，即会产生不可重复读的问题

##### MVCC加锁细节
```
delete from t1 where key=10
```
RC（读已提交）隔离级别下
- 如果key为主键索引，在主键索引上加x锁
- 如果key为唯一索引，在唯一索引上加x锁
- 如果key为二级非唯一索引，在所有对应的索引上加x锁
- 如果key没有索引，则会对所有数据加X锁，但如果不符合查询条件，会马上释放X锁

RR（可重复读）隔离级别下
为了不出现幻读，在第一条符合条件的数据和最后一条符合条件的数据两端加上GPA锁，不允许在此前后插入数据。


